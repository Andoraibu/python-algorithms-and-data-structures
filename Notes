Пайтон создает int, оно равно 24 байта, а так же дополнительно к нему ссылку на 8 байт, в сумме ~31 байт.
При удалении через 'del' удаляется ссылка в 8 байт, остается в памяти 24 байта (в какой момент удаляются?).
Вроде есть ещё арена какая-то, где хранятся мертвые объекты, и, если такой размер памяти нужен будет,
то это место памяти будет взято (?).
Пайтон сборщик мусора работает по принципу Reference counting.

Словари:
можно создавать через dict:
my_dict = dict(name="John")

Tuples: быстрее, чем листы.

*args - собирает оставшиеся параметры в тюпл.
**kwargs - returns dictionary.

Params order:
def (a, b, *args, default="Colt", **kwargs)

sys.getsizeof() - memory consumption
import sys
list_comp = sys.getsizeof([x * 10 for x in range(1000)]) # 9000 bytes
gen_exp = sys.getsizeof(x * 10 for x in range(1000))     # 88 bytes
Можно добавить генератор к листу [1,2] + gen()

len() за кулисами вызывае дандер метод [1,2,3].__len__

zip соединяет два одинаковых листа и можно или тюпл получить по два элемента или словарь
first = zip([1,2,3], [4,5,6])
list(first) # [(1,2), (3,4), (5,6)]
dict(first) # {1: 4, 2: 5, 3: 6}

except - в случае любой ошибки выдать то, что в этом блоке.
А, если конкретную ошибку хочу поймать, то пишу 'except KeyError', например. И еще 'finally' добавляю для любых других ошибок.

DEBUGGER
в пайтоне есть PDB.
import pdb
pdb.set_trace() - брейкпоинт для интерпретатора.
команды:
l(list)
n(next line)
p(print)
c(continue - finishes debugging)

В пайтоне можно в одну строку написать, только нужно семиколон:
import pdb; pdb.set_trace()



