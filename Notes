Пайтон создает int, оно равно 24 байта, а так же дополнительно к нему ссылку на 8 байт, в сумме ~31 байт.
При удалении через 'del' удаляется ссылка в 8 байт, остается в памяти 24 байта (в какой момент удаляются?).
Вроде есть ещё арена какая-то, где хранятся мертвые объекты, и, если такой размер памяти нужен будет,
то это место памяти будет взято (?).
Пайтон сборщик мусора работает по принципу Reference counting.

Словари:
можно создавать через dict:
my_dict = dict(name="John")

Tuples: быстрее, чем листы.

*args - собирает оставшиеся параметры в тюпл.
**kwargs - returns dictionary.

Params order:
def (a, b, *args, default="Colt", **kwargs)

sys.getsizeof() - memory consumption
import sys
list_comp = sys.getsizeof([x * 10 for x in range(1000)]) # 9000 bytes
gen_exp = sys.getsizeof(x * 10 for x in range(1000))     # 88 bytes
Можно добавить генератор к листу [1,2] + gen()

len() за кулисами вызывае дандер метод [1,2,3].__len__

zip соединяет два одинаковых листа и можно или тюпл получить по два элемента или словарь
first = zip([1,2,3], [4,5,6])
list(first) # [(1,2), (3,4), (5,6)]
dict(first) # {1: 4, 2: 5, 3: 6}

except - в случае любой ошибки выдать то, что в этом блоке.
А, если конкретную ошибку хочу поймать, то пишу 'except KeyError', например. И еще 'finally' добавляю для любых других ошибок.

DEBUGGER
в пайтоне есть PDB.
import pdb
pdb.set_trace() - брейкпоинт для интерпретатора.
команды:
l(list)
n(next line)
p(print)
c(continue - finishes debugging)

В пайтоне можно в одну строку написать, только нужно семиколон:
import pdb; pdb.set_trace()

__name__
создается для каждого файла.
и ей присваивается '__main__', если файл запущен. Если в этот файл импортирован модуль, то у модуля не будет мэйна, а свое имя в __name__.
Если в двух модулях есть if __name__ == '__main__', то код в этом условии будет выполнен только у того, куда импортировали,
а у импортируемого модуля - не будет выполнятся, поэтому это хорошая практика писать так.


Mangling the Attribute
class Person:
    def __init__(self):
    self.__name = "HELLO"
p = Person()
p.__name # ERROR, потому что за кулисами пайтон меняет имя у такой переменной с двумя подчеркиваниями (обычно на _ИмяКласса__ИмяЭтойПеременной _Person__name)
чтоб увидеть пишу print(dir(p)).


@property
In Python, property() is a built-in function that creates and returns a property object. The syntax of this function is:
property(fget=None, fset=None, fdel=None, doc=None). Смотри файл специальный.

print(c.__dict__) - возвращает класс в виде словаря.


'''class method можно вызвать 2мя способами'''
u = User()
print(u.display_active_users())
print(User.display_active_users()) # так предпочтительнее

Чтение файлов. Пайтон использует курсор для чтения. Открыл файл, прочитал - курсор в конец ушел, если еще раз попробовать открыть этот же файл - выдаст пустой тескст, т.к. в данный
момент курсор в конце стоит текста.
file.seek(0) - to reset.
Файл закрыл - прочитать нельзя больше.
file = open("file.txt")
file.read()
file.close()
ИЛИ с with:
with open("text.txt") as f:
    f.read()
И вот это with это вызов дандер метода file.__enter__() и потом закрытие file.__exit__().
When open a file"
r - read (by default)
w - write and overwrite
a - append to the end.
